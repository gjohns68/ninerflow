import discord
from discord import File
import io
import os
import json
import logging  
import requests
import re
import urllib
from playwright.async_api import async_playwright
import sys
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)

buildingInfoFile = open('uncc_buildings.json',)
buildingData = json.load(buildingInfoFile)

async def captureMapImage(playwright, to, dest):
    logging.info('captureMapImage called')
    browser = await playwright.chromium.launch(headless=False)
    context = await browser.new_context()
    # Open new page
    page = await context.new_page()
    await page.goto("https://maps.charlotte.edu/")
    await page.click("text=From To Go! >> input[type=\"text\"]")
    await page.fill("text=From To Go! >> input[type=\"text\"]", to +", Charlotte, NC, USA")
    await page.click("text="+to+" >> span")
    await page.click("text=To Go! >> input[type=\"text\"]")
    await page.fill("text=To Go! >> input[type=\"text\"]", dest + ", Charlotte, NC, USA")
    await page.click("text="+dest+" >> span")
    await page.click("css=[title='Walking']")
    await page.click("text=Go!")
    await page.wait_for_timeout(1000)
    summary_handle_1 = await page.query_selector("div.adp-summary > span:nth-child(1)")
    summary_handle_2 = await page.query_selector("div.adp-summary > span:nth-child(2)")
    summary_handle_3 = await page.query_selector("div.adp-summary > span:nth-child(3)")
    summary_handle_1 = await summary_handle_1.text_content()
    summary_handle_2 = await summary_handle_2.text_content()
    summary_handle_3 = await summary_handle_3.text_content()
    trip_summary = summary_handle_1 + summary_handle_2 + summary_handle_3
    await page.click("text=Map")
    await page.click("#map-canvas > div > div > div:nth-child(7) > div.gmnoprint.gm-style-mtc > ul > li:nth-child(3)")
    await page.evaluate("document.querySelector('#map-canvas > div > div > div:nth-child(7) > div.gmnoprint.gm-style-mtc').hidden=true");
    await page.evaluate("document.querySelector('body > div.ui-layer.container-fluid > div > div.col-sm-5.collapsable-col').hidden=true");
    canvas_handle = await page.query_selector("#map-canvas")
    bounding_box = await canvas_handle.bounding_box()
    if os.path.exists("screenshot.png"):
        os.remove("screenshot.png")
    await page.wait_for_timeout(200)
    screenshot_bytes = await canvas_handle.screenshot()
    await context.close()
    await browser.close()
    return trip_summary, screenshot_bytes

class MyClient(discord.Client):
    async def on_ready(self):
        print('Logged on as', self.user)

    async def on_message(self, message):
        # don't respond to ourselves
        if message.author == self.user:
            return

        if message.content == 'ping':
            await message.channel.send('pong')
        if message.content.startswith('!walk'):
           tripDetails = message.content[len("!walk"):].strip()
           tripDetails = tripDetails.split(',', 2)
           to = str(tripDetails[0])
           destination = str(tripDetails[1]).strip()
           logging.debug(to)
           logging.debug(destination)
           toBuildingInfo = list(filter(lambda x:x["building"].casefold()==to.casefold(),buildingData))[0]
        #TODO   if toBuildingInfo is None:
           destinationInfo = list(filter(lambda x:x["building"].casefold()==destination.casefold(),buildingData))[0]
        #TODO   if destinationInfo is None:
           to = toBuildingInfo.get('address')
           destination = destinationInfo.get('address')
           logging.debug(to)
           logging.debug(destination)
           async with async_playwright() as playwright:
               summary, screenshot_bytes = await captureMapImage(playwright,to,destination)
               screenshot_bytes = io.BytesIO(screenshot_bytes)
               await message.channel.send(content=summary,file=discord.File(screenshot_bytes, 'walking_map.png'))


        if message.content.startswith('distance'):
            longRe = "^(\+|-)?(?:180(?:(?:\.0{1,6})?)|(?:[0-9]|[1-9][0-9]|1[0-7][0-9])(?:(?:\.[0-9]{1,6})?))$"
            latRe = "^(\+|-)?((\d((\.)|\.\d{1,6})?)|(0*?[0-8]\d((\.)|\.\d{1,6})?)|(0*?90((\.)|\.0{1,6})?))$"

            parsedLocationPoints = message.content[len("distance"):-1]
            parsedLocationPoints = re.sub('[(|)|+]','',parsedLocationPoints)
            parsedLocationPoints = re.sub(' ','',parsedLocationPoints)
            index = parsedLocationPoints.index(',')
            latLongs = parsedLocationPoints.split(',', 4)
            n1 = str(latLongs[0])
            n2 = str(latLongs[1])
            n3 = str(latLongs[2])
            n4 = str(latLongs[3])
            qps = { 'destinations' : n1+","+n2, 'origins' : n3+","+n4}
            dynamicQueryParams = urllib.parse.urlencode(qps)

            url = "https://maps.googleapis.com/maps/api/distancematrix/json?"+dynamicQueryParams+"&units=imperial&key=AIzaSyAbx6pS5B8HPcloh5jRjVLb-JQxQJYSbPk"
            payload={}
            headers = {}
            response = requests.request("GET", url, headers=headers, data=payload)
            j = response.json()
            result = "could not calculate distance for this input"
            try:
                result = j['rows'][0]['elements'][0]['distance']['text'];
            except:
                pass
            await message.channel.send("The distance between these two points is "+result)


client = MyClient()
client.run(os.getenv('DISCORD_BOT_CLIENT_TOKEN'))










